We have two loops, one inside the other:

for (let i = 0; i < nums.length; i++) {
    for (let j = i + 1; j < nums.length; j++) {
        ...
    }
}


Hereâ€™s what happens in plain language:

The first loop picks a number.

The second loop checks that number against every other number that comes after it.

So if your array has:

5 numbers â†’ your code checks about 10 pairs.

10 numbers â†’ it checks about 45 pairs.

100 numbers â†’ it checks around 5,000 pairs! ğŸ˜…

![alt text](<Screenshot 2025-10-12 at 08.23.17.png>)

So the runtime complexity is:

O(nÂ²) â€” quadratic time.

You can see how it grows fast as the list gets bigger.
Thatâ€™s why we say itâ€™s O(nÂ²) (read as â€œbig O of n squaredâ€).
It means:

â€œIf the list doubles in size, the work becomes roughly four times as much.â€

ğŸ’¾ Space Complexity (O(1)) â€” â€œHow much extra memory it usesâ€

You only created a few things:

let positions = []
let indices = []


These donâ€™t grow much with the size of the array â€” they just hold one or two results at the end.

So even if the array has 10 or 10,000 numbers, your extra memory use stays almost the same.

Thatâ€™s called constant space â†’ O(1).

ğŸ§  Quick Recap
Concept	Meaning	In your code
O(nÂ²)	Work increases fast because you check every possible pair	Two nested loops
O(1)	Memory use stays small and steady	Only a few arrays and variables

