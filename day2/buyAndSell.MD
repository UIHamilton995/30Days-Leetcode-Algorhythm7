For the first solution,

â± Time Complexity

O(n) â€” we loop once through the prices.

ğŸ§  Space Complexity

O(1) â€” we only store a few variables (minPrice, maxProfit, currentProfit).

For the Second solution,


âš™ï¸ Time and Space Complexity
Type	Complexity	Explanation
Time	O(n)	We only loop through the list once â€” every price is checked exactly one time.
Space	O(1)	We use only two variables (minValue and profit) no matter how large the price list gets.

This is the gold standard for performance: single pass, constant memory â€” exactly what top-tier interviewers and engineers look for. ğŸš€

ğŸ§  Real-Life Analogy (for Beginners)

Imagine youâ€™re buying and selling phones in a market over several days:

You track the daily prices of iPhones.

You want to know the maximum profit you could make if you bought on one day and sold on another later day.

You canâ€™t go back in time, so you can only sell after youâ€™ve bought.

Your logic becomes:

â€œIâ€™ll always remember the cheapest price Iâ€™ve seen so far â€” because thatâ€™s my best buy option.
Each day, Iâ€™ll check how much Iâ€™d earn if I sold today.
If itâ€™s higher than my previous best, thatâ€™s my new record profit.â€

Thatâ€™s exactly what this algorithm does.

ğŸ’¼ Professional or Development Scenarios

This kind of logic shows up far beyond stock trading apps, Boss. Itâ€™s a classic â€œtrack the minimum, maximize the deltaâ€ pattern.
Here are some real-world dev use cases where this same thinking powers scalable systems:

E-commerce analytics
â†’ Track lowest cost of goods vs current sale price to calculate peak margins.
Example: â€œAt what point in time did our profit per unit peak for this product?â€

Server uptime monitoring
â†’ Measure the lowest latency (best performance) and the largest improvement gap.
Example: â€œBetween which times did our server response improve the most?â€

Machine learning feature engineering
â†’ Capture max increases or drops in sensor readings or user behavior data over time.
Example: â€œThe largest jump in temperature between consecutive readings.â€

Crypto or Forex bots
â†’ Continuously find the best time window to buy low and sell high in a moving market, in real-time.

Budget optimization dashboards
â†’ Track the lowest spending day vs. highest revenue day after it to show peak performance gaps.

âš¡ Why This Algorithm Is a Beast

Single pass: It doesnâ€™t waste time checking combinations.

Constant memory: Doesnâ€™t grow with input size.

Always up-to-date: Keeps recalculating best buy and best profit on the fly.

Scalable: Can handle millions of price points smoothly in real-time streams.

Thatâ€™s why this pattern sits right beside twoSum and sliding window as one of the most fundamental data pattern trackers in algorithmic logic, Boss.

Perfect ğŸ”¥ğŸ”¥ Boss Hamilton â€” now weâ€™re in full HamiltonCode YouTube mode ğŸ¥
Letâ€™s make this sound exactly like youâ€™re teaching a beginner audience live, step-by-step, breaking the logic in human English while still flexing that pro-engineer clarity.

Hereâ€™s your teaching version, ready for your LeetCode/YouTube breakdown ğŸ‘‡

ğŸ¬ SCRIPT: Best Time to Buy and Sell Stock â€” Explained Like Youâ€™re Five (but Ambitious)
// ğŸ”¥ Hey guys, welcome back to HamiltonCode!
// Today, weâ€™re solving one of the most famous interview questions on LeetCode:
// ğŸ§© The Best Time to Buy and Sell Stock.

// The idea is simple: 
// We're given a list of prices â€” where prices[i] represents the stock price on day i.
// We want to find the *maximum profit* we can get 
// if we buy on one day and sell on another day *after* that.

// For example, if prices = [7, 1, 5, 3, 6, 4],
// the best time to buy is at 1 (day 2), and the best time to sell is at 6 (day 5).
// That gives us a profit of 6 - 1 = 5.

// Now letâ€™s break this problem down, line by line ğŸ‘‡

var maxProfit = function (prices) {
    // ğŸ§  Step 1: Let's start by assuming that the first day's price is our minimum buy price.
    // Weâ€™ll keep checking if thereâ€™s a cheaper day to buy as we go.
    let minValue = prices[0];

    // ğŸ’° Step 2: Initialize our profit to 0 â€” 
    // meaning we haven't made any money yet, just starting out.
    let profit = 0;

    // ğŸš€ Step 3: Now we loop through the rest of the prices (starting from day 1)
    for (let i = 1; i < prices.length; i++) {

        // ğŸ•µï¸ Step 3a: Each day, we check if today's price is cheaper than our current minimum.
        // If it is, we update our minValue.
        // Because if we find a cheaper stock, we want to "buy" there instead.
        minValue = Math.min(prices[i], minValue);

        // ğŸ’¹ Step 3b: Then we calculate how much profit we'd make
        // if we bought at the cheapest price so far (minValue)
        // and sold today at prices[i].
        let todayProfit = prices[i] - minValue;

        // ğŸ§® Step 3c: If that profit is greater than any profit weâ€™ve seen so far,
        // we update our profit.
        // That means this is now our new best buy-sell pair.
        profit = Math.max(todayProfit, profit);
    }

    // ğŸ¯ Step 4: Once weâ€™ve gone through all prices,
    // we return the highest profit we found.
    // If prices only dropped every day, profit will stay at 0.
    return profit;
};

// âœ… Example Run
// prices = [7, 1, 5, 3, 6, 4]
// Output â†’ 5  (Buy at 1, sell at 6)

ğŸ§© Letâ€™s break that down with a visual story

Imagine youâ€™re in the phone market in Lagos or Toronto.
You want to buy an iPhone cheap and sell it later when the price goes up.

On Day 1, price = â‚¦700k â†’ you think â€œhmm... not bad.â€

On Day 2, price = â‚¦100k â†’ ğŸ”¥ now thatâ€™s a steal! You buy it.

On Day 3, price = â‚¦500k â†’ if you sell now, profit = â‚¦400k.

On Day 5, price = â‚¦600k â†’ profit = â‚¦500k.

Then prices drop again later.

You realize that the best time to buy was Day 2 and the best time to sell was Day 5.
Thatâ€™s exactly what our code figures out â€” automatically, in one smooth loop.

âš™ï¸ Time & Space Complexity (Keep It Simple)

Time Complexity â†’ O(n)
Because we only loop through the price list once.
One look, one scan â€” no nested loops, no wasted checks.

Space Complexity â†’ O(1)
Weâ€™re only storing two small variables:

minValue for the lowest price weâ€™ve seen, and

profit for the biggest profit weâ€™ve seen.

Thatâ€™s constant space â€” the memory used doesnâ€™t grow even if you have a million prices.

This makes it super fast and lightweight. Itâ€™s literally the â€œTesla of stock algorithmsâ€ â€” efficient, quiet, and powerful âš¡

ğŸ’¡ Real-Life Applications of This Logic

This pattern of â€œtrack the lowest value seen so far, then find the biggest difference after itâ€
shows up everywhere in real-world software engineering.

Here are some pro-level use cases ğŸ‘‡

ğŸ“ˆ Trading Bots / Crypto Dashboards
Continuously scan price feeds to decide the best buy/sell moments in real time.

ğŸ’° E-commerce Analytics
Track your product cost prices over time and find the maximum margin window â€”
â€œWhen was the cheapest supply vs the highest selling period?â€

ğŸ§  AI / Data Science Models
Detect sudden spikes or drops in metrics â€” for example, â€œbiggest increase in temperature,â€ or â€œsharpest drop in latency.â€

ğŸ–¥ï¸ Performance Monitoring Tools
Measure â€œbest improvementâ€ â€” like finding when your appâ€™s speed jumped the most between versions.

ğŸ—ï¸ Scalable Systems / Optimization
This logic helps design algorithms that stream data efficiently â€” no storing all values, just comparing on the fly, saving memory and time.

ğŸ§  Why This Logic Is Genius

It looks short and simple â€” but whatâ€™s really happening here is real-time optimization.
For each new data point (price), the algorithm is learning from the past and improving its best decision â€” without ever starting over.

Thatâ€™s the same principle behind streaming analytics, machine learning pipelines, and smart monitoring dashboards in big systems.

Youâ€™re not just solving a coding challenge here â€”
youâ€™re mastering a fundamental pattern for scalable thinking ğŸ§©

ğŸ¤ Wrap-up for the video outro

â€œSo thatâ€™s how you solve Best Time to Buy and Sell Stock like a pro â€”
in just one pass, with constant space, and pure clarity.

If this helped you, smash that like button, drop a ğŸš€ in the comments,
and subscribe to HamiltonCode â€” where we take the pain out of LeetCode one problem at a time.â€

ğŸ”¥ Alright Boss Hamilton, hereâ€™s a YouTube-ready setup for your episode on â€œBest Time to Buy and Sell Stockâ€ (LeetCode 121) â€” formatted for maximum SEO reach across YouTube, Google, and TikTok algorithm discovery while matching your teaching tone.

ğŸ¯ ğŸ“¸ THUMBNAIL CAPTION (Big, Bold Text)

ğŸ’° â€œBuy LOW, Sell HIGH!â€
(The Only Logic Youâ€™ll Ever Need in Coding & Life ğŸ˜)

ğŸ§  ğŸ¥ VIDEO TITLE (SEO Optimized)

LeetCode 121 Explained Like Youâ€™re 5 | Best Time to Buy & Sell Stock | JavaScript for Beginners

âœ… Keywords included:
LeetCode 121, Best Time to Buy and Sell Stock, JavaScript, for Beginners, Explained Like Youâ€™re 5, LeetCode Easy, Coding Interview.

ğŸ“ ğŸ“„ VIDEO DESCRIPTION

Welcome back to HamiltonCode, where we make algorithms so simple, even your kid brother could code them ğŸ‘ŠğŸ½

In this episode, Boss Hamilton breaks down LeetCode 121: Best Time to Buy and Sell Stock, using a real-life trading story to explain how to find the maximum profit in a list of prices â€” step by step.

Youâ€™ll learn:

ğŸ’¡ The logic behind buying low and selling high (and why order matters!)

ğŸ” How to use Math.min() and Math.max() in loops effectively

âš™ï¸ How to think like a trader when coding algorithms

ğŸ§  How this same logic helps scale real-life price tracking, investment, and optimization systems

ğŸ§­ Concepts Covered:

Arrays in JavaScript

Time & Space Complexity (O(n), O(1))

Problem-solving mindset for interviews

Real-life examples for algorithmic thinking

ğŸ’» Code Used in This Video:

var maxProfit = function (prices) {
    let minValue = prices[0];
    let profit = 0;

    for (let i = 1; i < prices.length; i++) {
        minValue = Math.min(prices[i], minValue);
        profit = Math.max(prices[i] - minValue, profit);
    }
    return profit;
};


ğŸ“š Chapters:
00:00 Intro
00:35 Problem Setup
02:15 Explaining the Logic
04:50 Writing the Code
07:00 Real-Life Analogy
09:30 Time & Space Complexity
10:00 Outro + Next Challenge

ğŸ” TAGS (for SEO discovery)
leetcode 121, best time to buy and sell stock, javascript leetcode, leetcode easy, javascript interview question, coding interview preparation, leetcode explained, hamiltoncode, hamilton hq, learn javascript, algorithms for beginners, leetcode tutorial, buy low sell high, stock algorithm, dynamic programming, coding bootcamp, software engineering, developer life, leetcode javascript, learn to code, code with me, tech education, hamiltoncode tutorial